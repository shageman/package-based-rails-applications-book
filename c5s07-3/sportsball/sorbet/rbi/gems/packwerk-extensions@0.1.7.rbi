# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `packwerk-extensions` gem.
# Please instead update this file by running `bin/tapioca gem packwerk-extensions`.

# source://packwerk-extensions//lib/packwerk/privacy/package.rb#4
module Packwerk; end

# source://packwerk-extensions//lib/packwerk/architecture/layers.rb#5
module Packwerk::Architecture; end

# This enforces "layered architecture," which allows each class to be designated as one of N layers
# configured by the client in `packwerk.yml`, for example:
#
# architecture_layers:
#   - orchestrator
#   - business_domain
#   - platform
#   - utility
#   - specification
#
# Then a package can configure:
# enforce_architecture: true | false | strict
# layer: utility
#
# This is intended to provide:
# A) Direction for which dependency violations to tackle
# B) What dependencies should or should not exist
# C) A potential sequencing for modularizing a system (starting with lower layers first).
#
# source://packwerk-extensions//lib/packwerk/architecture/checker.rb#29
class Packwerk::Architecture::Checker
  include ::Packwerk::Checker

  # source://packwerk-extensions//lib/packwerk/architecture/checker.rb#45
  sig { override.params(reference: ::Packwerk::Reference).returns(T::Boolean) }
  def invalid_reference?(reference); end

  # source://packwerk-extensions//lib/packwerk/architecture/checker.rb#93
  sig { returns(::Packwerk::Architecture::Layers) }
  def layers; end

  # source://packwerk-extensions//lib/packwerk/architecture/checker.rb#66
  sig { override.params(reference: ::Packwerk::Reference).returns(::String) }
  def message(reference); end

  # TODO: Extract this out into a common helper, can call it StandardViolationHelpMessage.new(...) and implements .to_s
  #
  # source://packwerk-extensions//lib/packwerk/architecture/checker.rb#83
  sig { params(reference: ::Packwerk::Reference).returns(::String) }
  def standard_help_message(reference); end

  # source://packwerk-extensions//lib/packwerk/architecture/checker.rb#56
  sig { override.params(listed_offense: ::Packwerk::ReferenceOffense).returns(T::Boolean) }
  def strict_mode_violation?(listed_offense); end

  # source://packwerk-extensions//lib/packwerk/architecture/checker.rb#36
  sig { override.returns(::String) }
  def violation_type; end
end

# source://packwerk-extensions//lib/packwerk/architecture/checker.rb#33
Packwerk::Architecture::Checker::VIOLATION_TYPE = T.let(T.unsafe(nil), String)

# source://packwerk-extensions//lib/packwerk/architecture/layers.rb#6
class Packwerk::Architecture::Layers
  # source://packwerk-extensions//lib/packwerk/architecture/layers.rb#10
  sig { void }
  def initialize; end

  # source://packwerk-extensions//lib/packwerk/architecture/layers.rb#16
  sig { params(layer: ::String).returns(::Integer) }
  def index_of(layer); end

  # source://packwerk-extensions//lib/packwerk/architecture/layers.rb#26
  sig { returns(T::Set[::String]) }
  def names; end

  private

  # source://packwerk-extensions//lib/packwerk/architecture/layers.rb#33
  sig { returns(T::Array[::String]) }
  def names_list; end
end

# source://packwerk-extensions//lib/packwerk/architecture/package.rb#6
class Packwerk::Architecture::Package < ::T::Struct
  const :layer, T.nilable(::String)
  const :enforcement_setting, T.nilable(T.any(::String, T::Array[::String], T::Boolean))
  const :config, T::Hash[T.untyped, T.untyped]

  # source://packwerk-extensions//lib/packwerk/architecture/package.rb#19
  sig do
    params(
      other_package: ::Packwerk::Architecture::Package,
      layers: ::Packwerk::Architecture::Layers
    ).returns(T::Boolean)
  end
  def can_depend_on?(other_package, layers:); end

  # source://packwerk-extensions//lib/packwerk/architecture/package.rb#14
  sig { returns(T::Boolean) }
  def enforces?; end

  class << self
    # source://packwerk-extensions//lib/packwerk/architecture/package.rb#34
    sig do
      params(
        package: ::Packwerk::Package,
        layers: ::Packwerk::Architecture::Layers
      ).returns(::Packwerk::Architecture::Package)
    end
    def from(package, layers); end

    # source://sorbet-runtime/0.5.10914/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://packwerk-extensions//lib/packwerk/architecture/validator.rb#6
class Packwerk::Architecture::Validator
  include ::Packwerk::Validator

  # source://packwerk-extensions//lib/packwerk/architecture/validator.rb#13
  sig do
    override
      .params(
        package_set: Packwerk::PackageSet,
        configuration: ::Packwerk::Configuration
      ).returns(::Packwerk::Validator::Result)
  end
  def call(package_set, configuration); end

  # source://packwerk-extensions//lib/packwerk/architecture/validator.rb#50
  sig do
    params(
      package_set: Packwerk::PackageSet,
      package: ::Packwerk::Architecture::Package,
      config_file_path: ::String
    ).returns(T::Array[::Packwerk::Validator::Result])
  end
  def check_dependencies_setting(package_set, package, config_file_path); end

  # source://packwerk-extensions//lib/packwerk/architecture/validator.rb#93
  sig { params(config_file_path: ::String, setting: T.untyped).returns(::Packwerk::Validator::Result) }
  def check_enforce_architecture_setting(config_file_path, setting); end

  # source://packwerk-extensions//lib/packwerk/architecture/validator.rb#71
  sig do
    params(
      package: ::Packwerk::Architecture::Package,
      config_file_path: ::String
    ).returns(::Packwerk::Validator::Result)
  end
  def check_layer_setting(package, config_file_path); end

  # source://packwerk-extensions//lib/packwerk/architecture/validator.rb#38
  sig { returns(::Packwerk::Architecture::Layers) }
  def layers; end

  # source://packwerk-extensions//lib/packwerk/architecture/validator.rb#43
  sig { override.returns(T::Array[::String]) }
  def permitted_keys; end
end

# source://packwerk-extensions//lib/packwerk/architecture/validator.rb#10
Packwerk::Architecture::Validator::Result = Packwerk::Validator::Result

# source://packwerk-extensions//lib/packwerk-extensions.rb#12
module Packwerk::Extensions; end

# source://packwerk-extensions//lib/packwerk/privacy/package.rb#5
module Packwerk::Privacy; end

# Checks whether a given reference references a private constant of another package.
#
# source://packwerk-extensions//lib/packwerk/privacy/checker.rb#10
class Packwerk::Privacy::Checker
  include ::Packwerk::Checker

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#26
  sig { override.params(reference: ::Packwerk::Reference).returns(T::Boolean) }
  def invalid_reference?(reference); end

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#55
  sig { override.params(reference: ::Packwerk::Reference).returns(::String) }
  def message(reference); end

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#45
  sig { override.params(listed_offense: ::Packwerk::ReferenceOffense).returns(T::Boolean) }
  def strict_mode_violation?(listed_offense); end

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#17
  sig { override.returns(::String) }
  def violation_type; end

  private

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#88
  sig { params(privacy_option: T.nilable(T.any(::String, T::Array[::String], T::Boolean))).returns(T::Boolean) }
  def enforcement_disabled?(privacy_option); end

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#76
  sig do
    params(
      constant: ::Packwerk::ConstantContext,
      explicitly_private_constants: T::Array[::String]
    ).returns(T::Boolean)
  end
  def explicitly_private_constant?(constant, explicitly_private_constants:); end

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#93
  sig { params(reference: ::Packwerk::Reference).returns(::String) }
  def standard_help_message(reference); end
end

# source://packwerk-extensions//lib/packwerk/privacy/checker.rb#14
Packwerk::Privacy::Checker::VIOLATION_TYPE = T.let(T.unsafe(nil), String)

# source://packwerk-extensions//lib/packwerk/privacy/package.rb#6
class Packwerk::Privacy::Package < ::T::Struct
  const :public_path, ::String
  const :user_defined_public_path, T.nilable(::String)
  const :enforce_privacy, T.nilable(T.any(::String, T::Boolean))
  const :private_constants, T::Array[::String]
  const :ignored_private_constants, T::Array[::String]

  # source://packwerk-extensions//lib/packwerk/privacy/package.rb#16
  sig { params(path: ::String).returns(T::Boolean) }
  def public_path?(path); end

  class << self
    # source://packwerk-extensions//lib/packwerk/privacy/package.rb#24
    sig { params(package: ::Packwerk::Package).returns(::Packwerk::Privacy::Package) }
    def from(package); end

    # source://sorbet-runtime/0.5.10914/lib/types/struct.rb#13
    def inherited(s); end

    # source://packwerk-extensions//lib/packwerk/privacy/package.rb#43
    sig { params(package: ::Packwerk::Package).returns(::String) }
    def public_path_for(package); end

    # source://packwerk-extensions//lib/packwerk/privacy/package.rb#35
    sig { params(package: ::Packwerk::Package).returns(T.nilable(::String)) }
    def user_defined_public_path(package); end
  end
end

# source://packwerk-extensions//lib/packwerk/privacy/validator.rb#6
class Packwerk::Privacy::Validator
  include ::Packwerk::Validator

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#13
  sig do
    override
      .params(
        package_set: Packwerk::PackageSet,
        configuration: ::Packwerk::Configuration
      ).returns(::Packwerk::Validator::Result)
  end
  def call(package_set, configuration); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#33
  sig { override.returns(T::Array[::String]) }
  def permitted_keys; end

  private

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#126
  sig { params(constants: T.untyped, config_file_path: ::String).returns(T::Array[::Packwerk::Validator::Result]) }
  def assert_constants_can_be_loaded(constants, config_file_path); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#95
  sig { params(config_file_path: ::String, setting: T.untyped).returns(::Packwerk::Validator::Result) }
  def check_enforce_privacy_setting(config_file_path, setting); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#110
  sig do
    params(
      configuration: ::Packwerk::Configuration,
      package_set: Packwerk::PackageSet,
      name: T.untyped,
      location: T.untyped,
      config_file_path: T.untyped
    ).returns(::Packwerk::Validator::Result)
  end
  def check_private_constant_location(configuration, package_set, name, location, config_file_path); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#81
  sig { params(config_file_path: ::String, setting: T.untyped).returns(::Packwerk::Validator::Result) }
  def check_public_path(config_file_path, setting); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#143
  sig { params(name: T.untyped, config_file_path: T.untyped).returns(::Packwerk::Validator::Result) }
  def private_constant_unresolvable(name, config_file_path); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#40
  sig do
    params(
      package_set: Packwerk::PackageSet,
      configuration: ::Packwerk::Configuration
    ).returns(T::Array[::Packwerk::Validator::Result])
  end
  def verify_private_constants_setting(package_set, configuration); end
end

# source://packwerk-extensions//lib/packwerk/privacy/validator.rb#10
Packwerk::Privacy::Validator::Result = Packwerk::Validator::Result

# source://packwerk-extensions//lib/packwerk/visibility/package.rb#5
module Packwerk::Visibility; end

# Checks whether a given reference references a constant from a package that does not permit visibility
#
# source://packwerk-extensions//lib/packwerk/visibility/checker.rb#10
class Packwerk::Visibility::Checker
  include ::Packwerk::Checker

  # source://packwerk-extensions//lib/packwerk/visibility/checker.rb#26
  sig { override.params(reference: ::Packwerk::Reference).returns(T::Boolean) }
  def invalid_reference?(reference); end

  # source://packwerk-extensions//lib/packwerk/visibility/checker.rb#50
  sig { override.params(reference: ::Packwerk::Reference).returns(::String) }
  def message(reference); end

  # source://packwerk-extensions//lib/packwerk/visibility/checker.rb#40
  sig { override.params(listed_offense: ::Packwerk::ReferenceOffense).returns(T::Boolean) }
  def strict_mode_violation?(listed_offense); end

  # source://packwerk-extensions//lib/packwerk/visibility/checker.rb#17
  sig { override.returns(::String) }
  def violation_type; end

  private

  # source://packwerk-extensions//lib/packwerk/visibility/checker.rb#69
  sig { params(visibility_option: T.nilable(T.any(::String, T::Boolean))).returns(T::Boolean) }
  def enforcement_disabled?(visibility_option); end

  # source://packwerk-extensions//lib/packwerk/visibility/checker.rb#74
  sig { params(reference: ::Packwerk::Reference).returns(::String) }
  def standard_help_message(reference); end
end

# source://packwerk-extensions//lib/packwerk/visibility/checker.rb#14
Packwerk::Visibility::Checker::VIOLATION_TYPE = T.let(T.unsafe(nil), String)

# source://packwerk-extensions//lib/packwerk/visibility/package.rb#6
class Packwerk::Visibility::Package < ::T::Struct
  const :visible_to, T::Array[::String]
  const :enforce_visibility, T.nilable(T.any(::String, T::Boolean))

  class << self
    # source://packwerk-extensions//lib/packwerk/visibility/package.rb#16
    sig { params(package: ::Packwerk::Package).returns(::Packwerk::Visibility::Package) }
    def from(package); end

    # source://sorbet-runtime/0.5.10914/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://packwerk-extensions//lib/packwerk/visibility/validator.rb#6
class Packwerk::Visibility::Validator
  include ::Packwerk::Validator

  # source://packwerk-extensions//lib/packwerk/visibility/validator.rb#13
  sig do
    override
      .params(
        package_set: Packwerk::PackageSet,
        configuration: ::Packwerk::Configuration
      ).returns(::Packwerk::Validator::Result)
  end
  def call(package_set, configuration); end

  # source://packwerk-extensions//lib/packwerk/visibility/validator.rb#54
  sig { override.returns(T::Array[::String]) }
  def permitted_keys; end
end

# source://packwerk-extensions//lib/packwerk/visibility/validator.rb#10
Packwerk::Visibility::Validator::Result = Packwerk::Validator::Result
