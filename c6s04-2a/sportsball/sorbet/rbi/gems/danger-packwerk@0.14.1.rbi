# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `danger-packwerk` gem.
# Please instead update this file by running `bin/tapioca gem danger-packwerk`.

# source://danger-packwerk//lib/danger-packwerk.rb#7
module DangerPackwerk; end

# We call this BasicReferenceOffense as it is intended to have a subset of the interface of Packwerk::ReferenceOffense, located here:
# https://github.com/Shopify/packwerk/blob/a22862b59f7760abf22bda6804d41a52d05301d8/lib/packwerk/reference_offense.rb#L1
# However, we cannot actually construct a Packwerk::ReferenceOffense from `package_todo.yml` alone, since they are normally
# constructed in packwerk when packwerk parses the AST and actually outputs `package_todo.yml`, a process in which some information,
# such as the location where the constant is defined, is lost.
#
# source://danger-packwerk//lib/danger-packwerk/basic_reference_offense.rb#11
class DangerPackwerk::BasicReferenceOffense < ::T::Struct
  const :class_name, ::String
  const :file, ::String
  const :to_package_name, ::String
  const :from_package_name, ::String
  const :type, ::String
  const :file_location, ::DangerPackwerk::BasicReferenceOffense::Location

  # source://danger-packwerk//lib/danger-packwerk/basic_reference_offense.rb#131
  sig { params(other: ::DangerPackwerk::BasicReferenceOffense).returns(T::Boolean) }
  def ==(other); end

  # source://danger-packwerk//lib/danger-packwerk/basic_reference_offense.rb#126
  sig { returns(T::Boolean) }
  def dependency?; end

  # source://danger-packwerk//lib/danger-packwerk/basic_reference_offense.rb#139
  sig { params(other: ::DangerPackwerk::BasicReferenceOffense).returns(T::Boolean) }
  def eql?(other); end

  # source://danger-packwerk//lib/danger-packwerk/basic_reference_offense.rb#144
  sig { returns(::Integer) }
  def hash; end

  # source://danger-packwerk//lib/danger-packwerk/basic_reference_offense.rb#121
  sig { returns(T::Boolean) }
  def privacy?; end

  class << self
    # source://danger-packwerk//lib/danger-packwerk/basic_reference_offense.rb#45
    sig { params(package_todo_yml: ::String).returns(T::Array[::DangerPackwerk::BasicReferenceOffense]) }
    def from(package_todo_yml); end

    # source://sorbet-runtime/0.5.10884/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://danger-packwerk//lib/danger-packwerk/basic_reference_offense.rb#12
class DangerPackwerk::BasicReferenceOffense::Location < ::T::Struct
  const :file, ::String
  const :line_number, ::Integer

  # These two methods exist so we can use `group_by` to group a `T::Array[BasicReferenceOffense]` by location.
  #
  # source://danger-packwerk//lib/danger-packwerk/basic_reference_offense.rb#22
  sig { params(other: ::DangerPackwerk::BasicReferenceOffense::Location).returns(T::Boolean) }
  def eql?(other); end

  # source://danger-packwerk//lib/danger-packwerk/basic_reference_offense.rb#27
  sig { returns(::Integer) }
  def hash; end

  class << self
    # source://sorbet-runtime/0.5.10884/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://danger-packwerk//lib/danger-packwerk/check/offenses_formatter.rb#6
module DangerPackwerk::Check; end

# source://danger-packwerk//lib/danger-packwerk/check/default_formatter.rb#7
class DangerPackwerk::Check::DefaultFormatter
  include ::DangerPackwerk::Check::OffensesFormatter

  # source://danger-packwerk//lib/danger-packwerk/check/default_formatter.rb#16
  sig { params(custom_help_message: T.nilable(::String)).void }
  def initialize(custom_help_message: T.unsafe(nil)); end

  # source://danger-packwerk//lib/danger-packwerk/check/default_formatter.rb#27
  sig do
    override
      .params(
        offenses: T::Array[::Packwerk::ReferenceOffense],
        repo_link: ::String,
        org_name: ::String
      ).returns(::String)
  end
  def format_offenses(offenses, repo_link, org_name); end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://danger-packwerk//lib/danger-packwerk/check/offenses_formatter.rb#7
module DangerPackwerk::Check::OffensesFormatter
  interface!

  # @abstract
  #
  # source://danger-packwerk//lib/danger-packwerk/check/offenses_formatter.rb#20
  sig do
    abstract
      .params(
        offenses: T::Array[::Packwerk::ReferenceOffense],
        repo_link: ::String,
        org_name: ::String
      ).returns(::String)
  end
  def format_offenses(offenses, repo_link, org_name); end
end

# source://danger-packwerk//lib/danger-packwerk.rb#9
DangerPackwerk::DEPENDENCY_VIOLATION_TYPE = T.let(T.unsafe(nil), String)

# source://danger-packwerk//lib/danger-packwerk/danger_package_todo_yml_changes.rb#12
class DangerPackwerk::DangerPackageTodoYmlChanges < ::Danger::Plugin
  # source://danger-packwerk//lib/danger-packwerk/danger_package_todo_yml_changes.rb#35
  sig do
    params(
      offenses_formatter: T.nilable(::DangerPackwerk::Update::OffensesFormatter),
      before_comment: T.proc.params(violation_diff: ::DangerPackwerk::ViolationDiff, changed_package_todo_ymls: T::Array[::String]).void,
      max_comments: ::Integer,
      violation_types: T::Array[::String]
    ).void
  end
  def check(offenses_formatter: T.unsafe(nil), before_comment: T.unsafe(nil), max_comments: T.unsafe(nil), violation_types: T.unsafe(nil)); end

  # source://danger-packwerk//lib/danger-packwerk/danger_package_todo_yml_changes.rb#72
  sig { params(violation_types: T::Array[::String]).returns(::DangerPackwerk::ViolationDiff) }
  def get_violation_diff(violation_types); end

  private

  # source://danger-packwerk//lib/danger-packwerk/danger_package_todo_yml_changes.rb#144
  sig { params(package_todo_yml_file: ::String).returns(T::Array[::DangerPackwerk::BasicReferenceOffense]) }
  def get_violations_before_patch_for(package_todo_yml_file); end
end

# source://danger-packwerk//lib/danger-packwerk/danger_package_todo_yml_changes.rb#20
DangerPackwerk::DangerPackageTodoYmlChanges::BeforeComment = T.type_alias { T.proc.params(violation_diff: ::DangerPackwerk::ViolationDiff, changed_package_todo_ymls: T::Array[::String]).void }

# source://danger-packwerk//lib/danger-packwerk/danger_package_todo_yml_changes.rb#21
DangerPackwerk::DangerPackageTodoYmlChanges::DEFAULT_BEFORE_COMMENT = T.let(T.unsafe(nil), Proc)

# We choose 5 here because violation additions tend to fall into a bimodal distribution, where most PRs only add a handful (<10) of new violations,
# but there are some that do a rename of an often-used variable, which can change hundreds of violations.
# Therefore we hope to capture the majority case of people making changes to code while not spamming PRs that do a big rename.
# We set a max (rather than unlimited) to avoid GitHub rate limiting and general spam if a PR does some sort of mass rename.
#
# source://danger-packwerk//lib/danger-packwerk/danger_package_todo_yml_changes.rb#19
DangerPackwerk::DangerPackageTodoYmlChanges::DEFAULT_MAX_COMMENTS = T.let(T.unsafe(nil), Integer)

# source://danger-packwerk//lib/danger-packwerk/danger_package_todo_yml_changes.rb#22
DangerPackwerk::DangerPackageTodoYmlChanges::DEFAULT_VIOLATION_TYPES = T.let(T.unsafe(nil), Array)

# Note that Danger names the plugin (i.e. anything that inherits from `Danger::Plugin`) by taking the name of the class and gsubbing out "Danger"
# Therefore this plugin is simply called "packwerk"
#
# source://danger-packwerk//lib/danger-packwerk/danger_packwerk.rb#13
class DangerPackwerk::DangerPackwerk < ::Danger::Plugin
  # source://danger-packwerk//lib/danger-packwerk/danger_packwerk.rb#49
  sig do
    params(
      offenses_formatter: T.nilable(::DangerPackwerk::Check::OffensesFormatter),
      max_comments: ::Integer,
      fail_build: T::Boolean,
      failure_message: ::String,
      on_failure: T.proc.params(offenses: T::Array[::Packwerk::ReferenceOffense]).void,
      violation_types: T::Array[::String],
      grouping_strategy: ::DangerPackwerk::DangerPackwerk::CommentGroupingStrategy
    ).void
  end
  def check(offenses_formatter: T.unsafe(nil), max_comments: T.unsafe(nil), fail_build: T.unsafe(nil), failure_message: T.unsafe(nil), on_failure: T.unsafe(nil), violation_types: T.unsafe(nil), grouping_strategy: T.unsafe(nil)); end
end

# source://danger-packwerk//lib/danger-packwerk/danger_packwerk.rb#29
class DangerPackwerk::DangerPackwerk::CommentGroupingStrategy < ::T::Enum
  enums do
    PerConstantPerLocation = new
    PerConstantPerPack = new
  end
end

# source://danger-packwerk//lib/danger-packwerk/danger_packwerk.rb#22
DangerPackwerk::DangerPackwerk::DEFAULT_FAIL = T.let(T.unsafe(nil), FalseClass)

# source://danger-packwerk//lib/danger-packwerk/danger_packwerk.rb#23
DangerPackwerk::DangerPackwerk::DEFAULT_FAILURE_MESSAGE = T.let(T.unsafe(nil), String)

# We choose 15 because we want to err on the side of completeness and give users all of the information they need to help make their build pass,
# especially given all violations should fail the build anyways.
# We set a max (rather than unlimited) to avoid GitHub rate limiting and general spam if a PR does some sort of mass rename.
#
# source://danger-packwerk//lib/danger-packwerk/danger_packwerk.rb#19
DangerPackwerk::DangerPackwerk::DEFAULT_MAX_COMMENTS = T.let(T.unsafe(nil), Integer)

# source://danger-packwerk//lib/danger-packwerk/danger_packwerk.rb#21
DangerPackwerk::DangerPackwerk::DEFAULT_ON_FAILURE = T.let(T.unsafe(nil), Proc)

# source://danger-packwerk//lib/danger-packwerk/danger_packwerk.rb#24
DangerPackwerk::DangerPackwerk::DEFAULT_VIOLATION_TYPES = T.let(T.unsafe(nil), Array)

# source://danger-packwerk//lib/danger-packwerk/danger_packwerk.rb#20
DangerPackwerk::DangerPackwerk::OnFailure = T.type_alias { T.proc.params(offenses: T::Array[::Packwerk::ReferenceOffense]).void }

# source://danger-packwerk//lib/danger-packwerk.rb#8
DangerPackwerk::PACKAGE_TODO_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://danger-packwerk//lib/danger-packwerk.rb#10
DangerPackwerk::PRIVACY_VIOLATION_TYPE = T.let(T.unsafe(nil), String)

# This class wraps packwerk to give us precisely what we want, which is the `Packwerk::ReferenceOffense` from a set of files.
# Note that statically packwerk returns `Packwerk::Offense` from running `bin/packwerk check`. The two types of `Packwerk::Offense` are
# `Packwerk::ReferenceOffense` and `Packwerk::Parsers::ParseResult`.`Packwerk::ReferenceOffense` inherits from `Packwerk::Offense`, and has more info than `Packwerk::Offense`.
# `Packwerk::Parsers::ParseResult` is returned when there is a file parsing issue. We ignore ParseResult types as it's likely that other tests would break along with this Danger check.
# and it is not the intent of this check to look for syntax errors in code.
#
# Also note that we would not need most of this class if there were two changes made to Packwerk:
# 1) It did not raise if no checkable files were found (I think it might make more sense to just return successfully rather than raise). This occurs if the
# input file list is excluded from the user's `exclude` list. In this case, check should return that no errors were found, since those files were not analyzed.
# 2) If the CLI gave a way to get offenses from files without this somewhat hacky way of passing in a formatter that stores the offenses.
#
# source://danger-packwerk//lib/danger-packwerk/packwerk_wrapper.rb#14
class DangerPackwerk::PackwerkWrapper
  class << self
    # source://danger-packwerk//lib/danger-packwerk/packwerk_wrapper.rb#18
    sig { params(files: T::Array[::String]).returns(T::Array[::Packwerk::ReferenceOffense]) }
    def get_offenses_for_files(files); end
  end
end

# This Packwerk formatter simply collects offenses. Ideally we could accomplish this by calling into public API of the CLI,
# but right now this is the only way to get the raw offenses out of packwerk.
#
# source://danger-packwerk//lib/danger-packwerk/packwerk_wrapper.rb#41
class DangerPackwerk::PackwerkWrapper::OffensesAggregatorFormatter
  include ::Packwerk::OffensesFormatter

  # source://danger-packwerk//lib/danger-packwerk/packwerk_wrapper.rb#49
  sig { void }
  def initialize; end

  # source://danger-packwerk//lib/danger-packwerk/packwerk_wrapper.rb#46
  sig { returns(T::Array[::Packwerk::Offense]) }
  def aggregated_offenses; end

  # source://danger-packwerk//lib/danger-packwerk/packwerk_wrapper.rb#70
  sig { override.returns(::String) }
  def identifier; end

  # source://danger-packwerk//lib/danger-packwerk/packwerk_wrapper.rb#54
  sig { override.params(offenses: T::Array[T.nilable(::Packwerk::Offense)]).returns(::String) }
  def show_offenses(offenses); end

  # source://danger-packwerk//lib/danger-packwerk/packwerk_wrapper.rb#60
  sig do
    override
      .params(
        offense_collection: ::Packwerk::OffenseCollection,
        for_files: T::Set[::String]
      ).returns(::String)
  end
  def show_stale_violations(offense_collection, for_files); end

  # source://danger-packwerk//lib/danger-packwerk/packwerk_wrapper.rb#65
  sig { override.params(strict_mode_violations: T::Array[::Packwerk::ReferenceOffense]).returns(::String) }
  def show_strict_mode_violations(strict_mode_violations); end
end

# Anything within the Private module is subject to change.
#
# source://danger-packwerk//lib/danger-packwerk/private/ownership_information.rb#7
module DangerPackwerk::Private
  class << self
    # source://danger-packwerk//lib/danger-packwerk/private.rb#14
    sig { returns(::ConstantResolver) }
    def constant_resolver; end
  end
end

# source://danger-packwerk//lib/danger-packwerk/private/ownership_information.rb#8
class DangerPackwerk::Private::OwnershipInformation < ::T::Struct
  const :owning_team, T.nilable(::CodeTeams::Team)
  const :github_team, T.nilable(::String)
  const :slack_channel, T.nilable(::String)
  const :org_name, T.nilable(::String)

  # Note this will NOT tag the team on Github, but it will link
  # to the mentioned team's members page. If you want to tag and
  # link the team, simply use the string and Github will handle it.
  #
  # source://danger-packwerk//lib/danger-packwerk/private/ownership_information.rb#57
  sig { returns(::String) }
  def markdown_link_to_github_members_no_tag; end

  # source://danger-packwerk//lib/danger-packwerk/private/ownership_information.rb#47
  sig { returns(::String) }
  def markdown_link_to_slack_room; end

  # source://danger-packwerk//lib/danger-packwerk/private/ownership_information.rb#34
  sig { returns(::String) }
  def ownership_copy; end

  class << self
    # source://danger-packwerk//lib/danger-packwerk/private/ownership_information.rb#17
    sig do
      params(
        package: ::ParsePackwerk::Package,
        org_name: ::String
      ).returns(::DangerPackwerk::Private::OwnershipInformation)
    end
    def for_package(package, org_name); end

    # source://sorbet-runtime/0.5.10884/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://danger-packwerk//lib/danger-packwerk/update/offenses_formatter.rb#6
module DangerPackwerk::Update; end

# source://danger-packwerk//lib/danger-packwerk/update/default_formatter.rb#5
class DangerPackwerk::Update::DefaultFormatter
  include ::DangerPackwerk::Update::OffensesFormatter

  # source://danger-packwerk//lib/danger-packwerk/update/default_formatter.rb#14
  sig { params(custom_help_message: T.nilable(::String)).void }
  def initialize(custom_help_message: T.unsafe(nil)); end

  # source://danger-packwerk//lib/danger-packwerk/update/default_formatter.rb#19
  sig do
    override
      .params(
        offenses: T::Array[::DangerPackwerk::BasicReferenceOffense],
        repo_link: ::String,
        org_name: ::String
      ).returns(::String)
  end
  def format_offenses(offenses, repo_link, org_name); end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://danger-packwerk//lib/danger-packwerk/update/offenses_formatter.rb#7
module DangerPackwerk::Update::OffensesFormatter
  interface!

  # @abstract
  #
  # source://danger-packwerk//lib/danger-packwerk/update/offenses_formatter.rb#20
  sig do
    abstract
      .params(
        offenses: T::Array[::DangerPackwerk::BasicReferenceOffense],
        repo_link: ::String,
        org_name: ::String
      ).returns(::String)
  end
  def format_offenses(offenses, repo_link, org_name); end
end

# This class represents the change in violations between a PR and its base.
#
# source://danger-packwerk//lib/danger-packwerk/violation_diff.rb#7
class DangerPackwerk::ViolationDiff < ::T::Struct
  const :added_violations, T::Array[::DangerPackwerk::BasicReferenceOffense]
  const :removed_violations, T::Array[::DangerPackwerk::BasicReferenceOffense]

  class << self
    # source://sorbet-runtime/0.5.10884/lib/types/struct.rb#13
    def inherited(s); end
  end
end
