# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pastel` gem.
# Please instead update this file by running `bin/tapioca gem pastel`.

# source://pastel//lib/pastel/alias_importer.rb#3
module Pastel
  private

  # Create Pastel chainable API
  #
  # @api public
  # @example
  #   pastel = Pastel.new enabled: true
  # @param :enabled [Boolean] whether or not to disable coloring
  # @param :eachline [Boolean] whether or not to wrap eachline with separate coloring
  # @return [Delegator]
  #
  # source://pastel//lib/pastel.rb#31
  def new(enabled: T.unsafe(nil), eachline: T.unsafe(nil)); end

  class << self
    # Create Pastel chainable API
    #
    # @api public
    # @example
    #   pastel = Pastel.new enabled: true
    # @param :enabled [Boolean] whether or not to disable coloring
    # @param :eachline [Boolean] whether or not to wrap eachline with separate coloring
    # @return [Delegator]
    #
    # source://pastel//lib/pastel.rb#31
    def new(enabled: T.unsafe(nil), eachline: T.unsafe(nil)); end
  end
end

# Mixin that provides ANSI codes
#
# source://pastel//lib/pastel/ansi.rb#5
module Pastel::ANSI
  private

  # source://pastel//lib/pastel/ansi.rb#62
  def background?(code); end

  # source://pastel//lib/pastel/ansi.rb#58
  def foreground?(code); end

  # source://pastel//lib/pastel/ansi.rb#66
  def style?(code); end

  class << self
    # @return [Boolean]
    #
    # source://pastel//lib/pastel/ansi.rb#62
    def background?(code); end

    # @return [Boolean]
    #
    # source://pastel//lib/pastel/ansi.rb#58
    def foreground?(code); end

    # @return [Boolean]
    #
    # source://pastel//lib/pastel/ansi.rb#66
    def style?(code); end
  end
end

# source://pastel//lib/pastel/ansi.rb#6
Pastel::ANSI::ATTRIBUTES = T.let(T.unsafe(nil), Hash)

# A class responsible for importing color aliases
#
# source://pastel//lib/pastel/alias_importer.rb#5
class Pastel::AliasImporter
  # Create alias importer
  #
  # @api public
  # @example
  #   importer = Pastel::AliasImporter.new(Pastel::Color.new, {})
  # @return [AliasImporter] a new instance of AliasImporter
  #
  # source://pastel//lib/pastel/alias_importer.rb#12
  def initialize(color, env, output = T.unsafe(nil)); end

  # Import aliases from the environment
  #
  # @api public
  # @example
  #   importer = Pastel::AliasImporter.new(Pastel::Color.new, {})
  #   importer.import
  # @return [nil]
  #
  # source://pastel//lib/pastel/alias_importer.rb#27
  def import; end

  protected

  # Returns the value of attribute color.
  #
  # source://pastel//lib/pastel/alias_importer.rb#44
  def color; end

  # Returns the value of attribute env.
  #
  # source://pastel//lib/pastel/alias_importer.rb#44
  def env; end

  # Returns the value of attribute output.
  #
  # source://pastel//lib/pastel/alias_importer.rb#44
  def output; end
end

# A class responsible for coloring strings.
#
# source://pastel//lib/pastel/color.rb#7
class Pastel::Color
  include ::Pastel::ANSI

  # Initialize a Terminal Color
  #
  # @api public
  # @return [Color] a new instance of Color
  #
  # source://pastel//lib/pastel/color.rb#24
  def initialize(enabled: T.unsafe(nil), eachline: T.unsafe(nil)); end

  # Compare colors for equivalence of attributes
  #
  # @api public
  # @return [Boolean]
  #
  # source://pastel//lib/pastel/color.rb#235
  def ==(other); end

  # Define a new colors alias
  #
  # @api public
  # @param alias_name [String] the colors alias to define
  # @param color [Array[Symbol,String]] the colors the alias will correspond to
  # @return [Array[String]] the standard color values of the alias
  #
  # source://pastel//lib/pastel/color.rb#206
  def alias_color(alias_name, *colors); end

  # Apply escape codes to the string
  #
  # @api private
  # @param string [String] the string to apply escapes to
  # @param ansi_colors [Strin] the ansi colors to apply
  # @return [String] return the string surrounded by escape codes
  #
  # source://pastel//lib/pastel/color.rb#78
  def apply_codes(string, ansi_colors); end

  # Reset sequence
  #
  # @api public
  #
  # source://pastel//lib/pastel/color.rb#85
  def clear; end

  # Return raw color code without embeding it into a string.
  #
  # @api public
  # @return [Array[String]] ANSI escape codes
  #
  # source://pastel//lib/pastel/color.rb#148
  def code(*colors); end

  # Check if string has color escape codes
  #
  # @api public
  # @param string [String] the string to check for color strings
  # @return [Boolean] true when string contains color codes, false otherwise
  #
  # source://pastel//lib/pastel/color.rb#117
  def colored?(string); end

  # Apply ANSI color to the given string.
  #
  # Wraps eachline with clear escape.
  #
  # @api public
  # @example
  #   color.decorate "text", :yellow, :on_green, :underline
  # @param string [String] text to add ANSI strings
  # @param colors [Array[Symbol]] the color names
  # @return [String] the colored string
  #
  # source://pastel//lib/pastel/color.rb#54
  def decorate(string, *colors); end

  # Disable coloring of this terminal session
  #
  # @api public
  #
  # source://pastel//lib/pastel/color.rb#33
  def disable!; end

  # Returns the value of attribute eachline.
  #
  # source://pastel//lib/pastel/color.rb#19
  def eachline; end

  # Returns the value of attribute enabled.
  #
  # source://pastel//lib/pastel/color.rb#16
  def enabled; end

  # Returns the value of attribute enabled.
  #
  # source://pastel//lib/pastel/color.rb#16
  def enabled?; end

  # Compare colors for equality of attributes
  #
  # @api public
  # @return [Boolean]
  #
  # source://pastel//lib/pastel/color.rb#225
  def eql?(other); end

  # Hash for this instance and its attributes
  #
  # @api public
  # @return [Numeric]
  #
  # source://pastel//lib/pastel/color.rb#254
  def hash; end

  # Inspect this instance attributes
  #
  # @api public
  # @return [String]
  #
  # source://pastel//lib/pastel/color.rb#245
  def inspect; end

  # Find the escape code for a given set of color attributes
  #
  # @api private
  # @example
  #   color.lookup(:red, :on_green) # => "\e[31;42m"
  # @param colors [Array[Symbol]] the list of color name(s) to lookup
  # @raise [InvalidAttributeNameError] exception raised for any invalid color name
  # @return [String] the ANSI code(s)
  #
  # source://pastel//lib/pastel/color.rb#136
  def lookup(*colors); end

  # Strip ANSI color codes from a string.
  #
  # Only ANSI color codes are removed, not movement codes or
  # other escapes sequences are stripped.
  #
  # @api public
  # @example
  #   strip("foo\e[1mbar\e[0m")  # => "foobar"
  # @param strings [Array[String]] a string or array of strings to sanitize
  # @return [String]
  #
  # source://pastel//lib/pastel/color.rb#103
  def strip(*strings); end

  # List all available style names
  #
  # @api public
  # @return [Array[Symbol]]
  #
  # source://pastel//lib/pastel/color.rb#175
  def style_names; end

  # Expose all ANSI color names and their codes
  #
  # @api public
  # @return [Hash[Symbol]]
  #
  # source://pastel//lib/pastel/color.rb#166
  def styles; end

  # Check if provided colors are known colors
  #
  # @api public
  # @example
  #   valid?(:red)   # => true
  # @param the [Array[Symbol,String]] list of colors to check
  # @return [Boolean] true if all colors are valid, false otherwise
  #
  # source://pastel//lib/pastel/color.rb#191
  def valid?(*colors); end

  private

  # Check if value contains anything to style
  #
  # @api private
  # @return [Boolean]
  #
  # source://pastel//lib/pastel/color.rb#265
  def blank?(value); end

  # @api private
  # @raise [InvalidAttributeNameError]
  #
  # source://pastel//lib/pastel/color.rb#270
  def validate(*colors); end
end

# All color aliases
#
# source://pastel//lib/pastel/color.rb#11
Pastel::Color::ALIASES = T.let(T.unsafe(nil), Hash)

# Match all color escape sequences
#
# source://pastel//lib/pastel/color.rb#14
Pastel::Color::ANSI_COLOR_REGEXP = T.let(T.unsafe(nil), Regexp)

# Responsible for parsing color symbols out of text with color escapes
#
# Used internally by {Color}.
#
# @api private
#
# source://pastel//lib/pastel/color_parser.rb#13
class Pastel::ColorParser
  include ::Pastel::ANSI

  class << self
    # Decide attribute name for ansi
    #
    # @api private
    # @param ansi [Integer] the ansi escape code
    # @return [Symbol]
    #
    # source://pastel//lib/pastel/color_parser.rb#104
    def attribute_name(ansi); end

    # Convert ANSI code to color name
    #
    # @api private
    # @return [String]
    #
    # source://pastel//lib/pastel/color_parser.rb#119
    def color_name(ansi_code); end

    # Parse color escape sequences into a list of hashes
    # corresponding to the color attributes being set by these
    # sequences
    #
    # @api public
    # @example
    #   parse("\e[32mfoo\e[0m")
    #   # => [{foreground: :green, text: "foo"}
    # @param text [String] the text to parse for presence of color ansi codes
    # @return [Array[Hash[Symbol,String]]]
    #
    # source://pastel//lib/pastel/color_parser.rb#33
    def parse(text); end

    # Remove from current stack all ansi codes
    #
    # @api private
    # @param ansi_stack [Array[Integer]] the stack with all the ansi codes
    # @yield [Symbol, Symbol] attr, name
    #
    # source://pastel//lib/pastel/color_parser.rb#90
    def unpack_ansi(ansi_stack); end
  end
end

# @api private
#
# source://pastel//lib/pastel/color_parser.rb#17
Pastel::ColorParser::CSI = T.let(T.unsafe(nil), String)

# @api private
#
# source://pastel//lib/pastel/color_parser.rb#16
Pastel::ColorParser::ESC = T.let(T.unsafe(nil), String)

# Contains logic for resolving styles applied to component
#
# Used internally by {Delegator}.
#
# @api private
#
# source://pastel//lib/pastel/color_resolver.rb#11
class Pastel::ColorResolver
  # Initialize ColorResolver
  #
  # @api private
  # @param color [Color]
  # @return [ColorResolver] a new instance of ColorResolver
  #
  # source://pastel//lib/pastel/color_resolver.rb#21
  def initialize(color); end

  # The color instance
  #
  # @api public
  #
  # source://pastel//lib/pastel/color_resolver.rb#14
  def color; end

  # Resolve uncolored string
  #
  # @api private
  #
  # source://pastel//lib/pastel/color_resolver.rb#28
  def resolve(base, unprocessed_string); end
end

# Collects a list of decorators for styling a string
#
# @api private
#
# source://pastel//lib/pastel/decorator_chain.rb#7
class Pastel::DecoratorChain
  include ::Enumerable

  # Create a decorator chain
  #
  # @api public
  # @return [DecoratorChain] a new instance of DecoratorChain
  #
  # source://pastel//lib/pastel/decorator_chain.rb#22
  def initialize(decorators = T.unsafe(nil)); end

  # Compare colors for equivalence of attributes
  #
  # @api public
  # @return [Boolean]
  #
  # source://pastel//lib/pastel/decorator_chain.rb#60
  def ==(other); end

  # Add decorator
  #
  # @api public
  # @param decorator [String]
  #
  # source://pastel//lib/pastel/decorator_chain.rb#31
  def add(decorator); end

  # Iterate over list of decorators
  #
  # @api public
  #
  # source://pastel//lib/pastel/decorator_chain.rb#42
  def each(&block); end

  # Compare colors for equality of attributes
  #
  # @api public
  # @return [Boolean]
  #
  # source://pastel//lib/pastel/decorator_chain.rb#51
  def eql?(other); end

  # Hash for this instance and its attributes
  #
  # @api public
  # @return [Numeric]
  #
  # source://pastel//lib/pastel/decorator_chain.rb#78
  def hash; end

  # Inspect this instance attributes
  #
  # @api public
  # @return [String]
  #
  # source://pastel//lib/pastel/decorator_chain.rb#69
  def inspect; end

  protected

  # @api private
  #
  # source://pastel//lib/pastel/decorator_chain.rb#84
  def decorators; end

  class << self
    # Create an empty decorator chain
    #
    # @api public
    # @return [DecoratorChain]
    #
    # source://pastel//lib/pastel/decorator_chain.rb#15
    def empty; end
  end
end

# Wrapes the {DecoratorChain} to allow for easy resolution
# of string coloring.
#
# @api private
#
# source://pastel//lib/pastel/delegator.rb#13
class Pastel::Delegator
  extend ::Forwardable

  # Create Delegator
  #
  # Used internally by {Pastel}
  #
  # @api private
  # @param resolver [ColorResolver]
  # @param chain [DecoratorChain]
  # @return [Delegator] a new instance of Delegator
  #
  # source://pastel//lib/pastel/delegator.rb#38
  def initialize(resolver, chain); end

  # Compare delegated objects for equivalence of attributes
  #
  # @api public
  # @return [Boolean]
  #
  # source://pastel//lib/pastel/delegator.rb#57
  def ==(other); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def alias_color(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def colored?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def decorate(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def enabled?(*args, **_arg1, &block); end

  # Compare delegated objects for equality of attributes
  #
  # @api public
  # @return [Boolean]
  #
  # source://pastel//lib/pastel/delegator.rb#48
  def eql?(other); end

  # Hash for this instance and its attributes
  #
  # @api public
  # @return [Numeric]
  #
  # source://pastel//lib/pastel/delegator.rb#76
  def hash; end

  # Object string representation
  #
  # @api
  # @return [String]
  #
  # source://pastel//lib/pastel/delegator.rb#66
  def inspect; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def lookup(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def parse(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def strip(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def styles(*args, **_arg1, &block); end

  # Object string representation
  #
  # @api
  # @return [String]
  #
  # source://pastel//lib/pastel/delegator.rb#66
  def to_s; end

  # @api private
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def undecorate(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def valid?(*args, **_arg1, &block); end

  protected

  # @api private
  #
  # source://pastel//lib/pastel/delegator.rb#82
  def chain; end

  # Evaluate color block
  #
  # @api private
  #
  # source://pastel//lib/pastel/delegator.rb#112
  def evaluate_block(&block); end

  # Handles color method calls
  #
  # @api private
  #
  # source://pastel//lib/pastel/delegator.rb#89
  def method_missing(method_name, *args, &block); end

  # @api private
  #
  # source://pastel//lib/pastel/delegator.rb#84
  def resolver; end

  private

  # Check if color is valid
  #
  # @api private
  # @return [Boolean]
  #
  # source://pastel//lib/pastel/delegator.rb#104
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end

  class << self
    # Wrap resolver and chain
    #
    # @api public
    #
    # source://pastel//lib/pastel/delegator.rb#25
    def wrap(resolver, chain = T.unsafe(nil)); end
  end
end

# A class representing detached color
#
# source://pastel//lib/pastel/detached.rb#5
class Pastel::Detached
  # Initialize a detached object
  #
  # @api private
  # @param color [Pastel::Color] the color instance
  # @param styles [Array[Symbol]] the styles to be applied
  # @return [Detached] a new instance of Detached
  #
  # source://pastel//lib/pastel/detached.rb#14
  def initialize(color, *styles); end

  # Compare detached objects for equivalence of attributes
  #
  # @api public
  # @return [Boolean]
  #
  # source://pastel//lib/pastel/detached.rb#57
  def ==(other); end

  # Decorate the values corresponding to styles
  #
  # @api public
  # @example
  #   Detached(Color.new, :red, :bold).call("hello")
  #   # => "\e[31mhello\e[0m"
  # @param value [String] the stirng to decorate with styles
  # @return [String]
  #
  # source://pastel//lib/pastel/detached.rb#32
  def [](*args); end

  # Decorate the values corresponding to styles
  #
  # @api public
  # @example
  #   Detached(Color.new, :red, :bold).call("hello")
  #   # => "\e[31mhello\e[0m"
  # @param value [String] the stirng to decorate with styles
  # @return [String]
  #
  # source://pastel//lib/pastel/detached.rb#32
  def call(*args); end

  # Compare detached objects for equality of attributes
  #
  # @api public
  # @return [Boolean]
  #
  # source://pastel//lib/pastel/detached.rb#48
  def eql?(other); end

  # Hash for this instance and its attributes
  #
  # @api public
  # @return [Numeric]
  #
  # source://pastel//lib/pastel/detached.rb#75
  def hash; end

  # Inspect this instance attributes
  #
  # @api public
  # @return [String]
  #
  # source://pastel//lib/pastel/detached.rb#66
  def inspect; end

  # @api public
  #
  # source://pastel//lib/pastel/detached.rb#39
  def to_proc; end

  protected

  # @api private
  #
  # source://pastel//lib/pastel/detached.rb#82
  def styles; end
end

# Raised when the color alias is not supported
#
# source://pastel//lib/pastel.rb#16
class Pastel::InvalidAliasNameError < ::ArgumentError; end

# Raised when the style attribute is not supported
#
# source://pastel//lib/pastel.rb#13
class Pastel::InvalidAttributeNameError < ::ArgumentError; end

# source://pastel//lib/pastel/version.rb#4
Pastel::VERSION = T.let(T.unsafe(nil), String)
