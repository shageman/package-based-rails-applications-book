# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `packwerk-extensions` gem.
# Please instead update this file by running `bin/tapioca gem packwerk-extensions`.


# source://packwerk-extensions//lib/packwerk/privacy/package.rb#4
module Packwerk; end

# source://packwerk-extensions//lib/packwerk-extensions.rb#13
module Packwerk::Extensions; end

# source://packwerk-extensions//lib/packwerk/folder_privacy/package.rb#5
module Packwerk::FolderPrivacy; end

# source://packwerk-extensions//lib/packwerk/folder_privacy/checker.rb#9
class Packwerk::FolderPrivacy::Checker
  include ::Packwerk::Checker

  # source://packwerk-extensions//lib/packwerk/folder_privacy/checker.rb#25
  sig { override.params(reference: ::Packwerk::Reference).returns(T::Boolean) }
  def invalid_reference?(reference); end

  # source://packwerk-extensions//lib/packwerk/folder_privacy/checker.rb#59
  sig { override.params(reference: ::Packwerk::Reference).returns(::String) }
  def message(reference); end

  # source://packwerk-extensions//lib/packwerk/folder_privacy/checker.rb#49
  sig { override.params(listed_offense: ::Packwerk::ReferenceOffense).returns(T::Boolean) }
  def strict_mode_violation?(listed_offense); end

  # source://packwerk-extensions//lib/packwerk/folder_privacy/checker.rb#16
  sig { override.returns(::String) }
  def violation_type; end

  private

  # source://packwerk-extensions//lib/packwerk/folder_privacy/checker.rb#78
  sig { params(visibility_option: T.nilable(T.any(::String, T::Boolean))).returns(T::Boolean) }
  def enforcement_disabled?(visibility_option); end

  # source://packwerk-extensions//lib/packwerk/folder_privacy/checker.rb#83
  sig { params(reference: ::Packwerk::Reference).returns(::String) }
  def standard_help_message(reference); end
end

# source://packwerk-extensions//lib/packwerk/folder_privacy/checker.rb#13
Packwerk::FolderPrivacy::Checker::VIOLATION_TYPE = T.let(T.unsafe(nil), String)

# source://packwerk-extensions//lib/packwerk/folder_privacy/package.rb#6
class Packwerk::FolderPrivacy::Package < ::T::Struct
  const :enforce_folder_privacy, T.nilable(T.any(::String, T::Boolean))

  class << self
    # source://packwerk-extensions//lib/packwerk/folder_privacy/package.rb#15
    sig { params(package: ::Packwerk::Package).returns(::Packwerk::FolderPrivacy::Package) }
    def from(package); end

    # source://sorbet-runtime/0.5.11835/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://packwerk-extensions//lib/packwerk/folder_privacy/validator.rb#6
class Packwerk::FolderPrivacy::Validator
  include ::Packwerk::Validator

  # source://packwerk-extensions//lib/packwerk/folder_privacy/validator.rb#13
  sig do
    override
      .params(
        package_set: Packwerk::PackageSet,
        configuration: ::Packwerk::Configuration
      ).returns(::Packwerk::Validator::Result)
  end
  def call(package_set, configuration); end

  # source://packwerk-extensions//lib/packwerk/folder_privacy/validator.rb#31
  sig { override.returns(T::Array[::String]) }
  def permitted_keys; end
end

# source://packwerk-extensions//lib/packwerk/folder_privacy/validator.rb#10
Packwerk::FolderPrivacy::Validator::Result = Packwerk::Validator::Result

# source://packwerk-extensions//lib/packwerk/layer/config.rb#5
module Packwerk::Layer; end

# This enforces "layered architecture," which allows each class to be designated as one of N layers
# configured by the client in `packwerk.yml`, for example:
#
# layers:
#   - orchestrator
#   - business_domain
#   - platform
#   - utility
#   - specification
#
# Then a package can configure:
# enforce_layers: true | false | strict
# layer: utility
#
# This is intended to provide:
# A) Direction for which dependency violations to tackle
# B) What dependencies should or should not exist
# C) A potential sequencing for modularizing a system (starting with lower layers first).
#
# source://packwerk-extensions//lib/packwerk/layer/checker.rb#30
class Packwerk::Layer::Checker
  include ::Packwerk::Checker

  # source://packwerk-extensions//lib/packwerk/layer/checker.rb#35
  sig { void }
  def initialize; end

  # source://packwerk-extensions//lib/packwerk/layer/checker.rb#49
  sig { override.params(reference: ::Packwerk::Reference).returns(T::Boolean) }
  def invalid_reference?(reference); end

  # source://packwerk-extensions//lib/packwerk/layer/checker.rb#103
  sig { returns(::Packwerk::Layer::Config) }
  def layer_config; end

  # source://packwerk-extensions//lib/packwerk/layer/checker.rb#98
  sig { returns(::Packwerk::Layer::Layers) }
  def layers; end

  # source://packwerk-extensions//lib/packwerk/layer/checker.rb#70
  sig { override.params(reference: ::Packwerk::Reference).returns(::String) }
  def message(reference); end

  # TODO: Extract this out into a common helper, can call it StandardViolationHelpMessage.new(...) and implements .to_s
  #
  # source://packwerk-extensions//lib/packwerk/layer/checker.rb#88
  sig { params(reference: ::Packwerk::Reference).returns(::String) }
  def standard_help_message(reference); end

  # source://packwerk-extensions//lib/packwerk/layer/checker.rb#60
  sig { override.params(listed_offense: ::Packwerk::ReferenceOffense).returns(T::Boolean) }
  def strict_mode_violation?(listed_offense); end

  # source://packwerk-extensions//lib/packwerk/layer/checker.rb#40
  sig { override.returns(::String) }
  def violation_type; end
end

# source://packwerk-extensions//lib/packwerk/layer/config.rb#6
class Packwerk::Layer::Config
  # source://packwerk-extensions//lib/packwerk/layer/config.rb#15
  sig { void }
  def initialize; end

  # source://packwerk-extensions//lib/packwerk/layer/config.rb#41
  sig { returns(::String) }
  def enforce_key; end

  # source://packwerk-extensions//lib/packwerk/layer/config.rb#31
  sig { returns(::String) }
  def layers_key; end

  # source://packwerk-extensions//lib/packwerk/layer/config.rb#26
  sig { returns(T::Boolean) }
  def layers_key_configured?; end

  # source://packwerk-extensions//lib/packwerk/layer/config.rb#21
  sig { returns(T::Array[::String]) }
  def layers_list; end

  # source://packwerk-extensions//lib/packwerk/layer/config.rb#36
  sig { returns(::String) }
  def violation_key; end
end

# source://packwerk-extensions//lib/packwerk/layer/config.rb#10
Packwerk::Layer::Config::ARCHITECTURE_ENFORCE = T.let(T.unsafe(nil), String)

# source://packwerk-extensions//lib/packwerk/layer/config.rb#9
Packwerk::Layer::Config::ARCHITECTURE_VIOLATION_TYPE = T.let(T.unsafe(nil), String)

# source://packwerk-extensions//lib/packwerk/layer/config.rb#12
Packwerk::Layer::Config::LAYER_ENFORCE = T.let(T.unsafe(nil), String)

# source://packwerk-extensions//lib/packwerk/layer/config.rb#11
Packwerk::Layer::Config::LAYER_VIOLATION_TYPE = T.let(T.unsafe(nil), String)

# source://packwerk-extensions//lib/packwerk/layer/layers.rb#6
class Packwerk::Layer::Layers
  # source://packwerk-extensions//lib/packwerk/layer/layers.rb#10
  sig { void }
  def initialize; end

  # source://packwerk-extensions//lib/packwerk/layer/layers.rb#16
  sig { params(layer: ::String).returns(::Integer) }
  def index_of(layer); end

  # source://packwerk-extensions//lib/packwerk/layer/layers.rb#26
  sig { returns(T::Set[::String]) }
  def names; end

  # source://packwerk-extensions//lib/packwerk/layer/layers.rb#31
  sig { returns(T::Array[::String]) }
  def names_list; end
end

# source://packwerk-extensions//lib/packwerk/layer/package.rb#6
class Packwerk::Layer::Package < ::T::Struct
  const :layer, T.nilable(::String)
  const :enforcement_setting, T.nilable(T.any(::String, T::Array[::String], T::Boolean))
  const :config, T::Hash[T.untyped, T.untyped]

  # source://packwerk-extensions//lib/packwerk/layer/package.rb#19
  sig { params(other_package: ::Packwerk::Layer::Package, layers: ::Packwerk::Layer::Layers).returns(T::Boolean) }
  def can_depend_on?(other_package, layers:); end

  # source://packwerk-extensions//lib/packwerk/layer/package.rb#14
  sig { returns(T::Boolean) }
  def enforces?; end

  class << self
    # source://packwerk-extensions//lib/packwerk/layer/package.rb#34
    sig { params(package: ::Packwerk::Package, layers: ::Packwerk::Layer::Layers).returns(::Packwerk::Layer::Package) }
    def from(package, layers); end

    # source://sorbet-runtime/0.5.11835/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://packwerk-extensions//lib/packwerk/layer/validator.rb#6
class Packwerk::Layer::Validator
  include ::Packwerk::Validator

  # source://packwerk-extensions//lib/packwerk/layer/validator.rb#13
  sig do
    override
      .params(
        package_set: Packwerk::PackageSet,
        configuration: ::Packwerk::Configuration
      ).returns(::Packwerk::Validator::Result)
  end
  def call(package_set, configuration); end

  # source://packwerk-extensions//lib/packwerk/layer/validator.rb#57
  sig do
    params(
      package: ::Packwerk::Layer::Package,
      config_file_path: ::String,
      config: T::Hash[T.untyped, T.untyped]
    ).returns(::Packwerk::Validator::Result)
  end
  def check_enforce_key(package, config_file_path, config); end

  # source://packwerk-extensions//lib/packwerk/layer/validator.rb#101
  sig { params(config_file_path: ::String, setting: T.untyped).returns(::Packwerk::Validator::Result) }
  def check_enforce_layers_setting(config_file_path, setting); end

  # source://packwerk-extensions//lib/packwerk/layer/validator.rb#79
  sig do
    params(
      package: ::Packwerk::Layer::Package,
      config_file_path: ::String
    ).returns(::Packwerk::Validator::Result)
  end
  def check_layer_setting(package, config_file_path); end

  # source://packwerk-extensions//lib/packwerk/layer/validator.rb#45
  sig { returns(::Packwerk::Layer::Config) }
  def layer_config; end

  # source://packwerk-extensions//lib/packwerk/layer/validator.rb#40
  sig { returns(::Packwerk::Layer::Layers) }
  def layers; end

  # source://packwerk-extensions//lib/packwerk/layer/validator.rb#50
  sig { override.returns(T::Array[::String]) }
  def permitted_keys; end
end

# source://packwerk-extensions//lib/packwerk/layer/validator.rb#10
Packwerk::Layer::Validator::Result = Packwerk::Validator::Result

# source://packwerk-extensions//lib/packwerk/privacy/package.rb#5
module Packwerk::Privacy; end

# Checks whether a given reference references a private constant of another package.
#
# source://packwerk-extensions//lib/packwerk/privacy/checker.rb#10
class Packwerk::Privacy::Checker
  include ::Packwerk::Checker

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#57
  sig { override.params(reference: ::Packwerk::Reference).returns(T::Boolean) }
  def invalid_reference?(reference); end

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#94
  sig { override.params(reference: ::Packwerk::Reference).returns(::String) }
  def message(reference); end

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#77
  sig { override.params(listed_offense: ::Packwerk::ReferenceOffense).returns(T::Boolean) }
  def strict_mode_violation?(listed_offense); end

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#48
  sig { override.returns(::String) }
  def violation_type; end

  private

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#127
  sig { params(privacy_option: T.nilable(T.any(::String, T::Array[::String], T::Boolean))).returns(T::Boolean) }
  def enforcement_disabled?(privacy_option); end

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#142
  sig { params(globs: T::Array[::String], path: ::Pathname).returns(T::Boolean) }
  def exclude_from_strict?(globs, path); end

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#115
  sig do
    params(
      constant: ::Packwerk::ConstantContext,
      explicitly_private_constants: T::Array[::String]
    ).returns(T::Boolean)
  end
  def explicitly_private_constant?(constant, explicitly_private_constants:); end

  # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#132
  sig { params(reference: ::Packwerk::Reference).returns(::String) }
  def standard_help_message(reference); end

  class << self
    # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#37
    sig { params(location: ::String).returns(T::Boolean) }
    def check_for_publicized_sigil(location); end

    # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#42
    sig { params(lines: T::Array[::String]).returns(T::Boolean) }
    def content_contains_sigil?(lines); end

    # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#28
    sig { params(location: ::String).returns(T::Boolean) }
    def publicized_location?(location); end

    # source://packwerk-extensions//lib/packwerk/privacy/checker.rb#23
    sig { returns(T::Hash[::String, T::Boolean]) }
    def publicized_locations; end
  end
end

# source://packwerk-extensions//lib/packwerk/privacy/checker.rb#15
Packwerk::Privacy::Checker::PUBLICIZED_SIGIL = T.let(T.unsafe(nil), String)

# source://packwerk-extensions//lib/packwerk/privacy/checker.rb#16
Packwerk::Privacy::Checker::PUBLICIZED_SIGIL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://packwerk-extensions//lib/packwerk/privacy/checker.rb#14
Packwerk::Privacy::Checker::VIOLATION_TYPE = T.let(T.unsafe(nil), String)

# source://packwerk-extensions//lib/packwerk/privacy/package.rb#6
class Packwerk::Privacy::Package < ::T::Struct
  const :public_path, ::String
  const :user_defined_public_path, T.nilable(::String)
  const :enforce_privacy, T.nilable(T.any(::String, T::Boolean))
  const :private_constants, T::Array[::String]
  const :ignored_private_constants, T::Array[::String]
  const :strict_privacy_ignored_patterns, T::Array[::String]

  # source://packwerk-extensions//lib/packwerk/privacy/package.rb#17
  sig { params(path: ::String).returns(T::Boolean) }
  def public_path?(path); end

  class << self
    # source://packwerk-extensions//lib/packwerk/privacy/package.rb#25
    sig { params(package: ::Packwerk::Package).returns(::Packwerk::Privacy::Package) }
    def from(package); end

    # source://sorbet-runtime/0.5.11835/lib/types/struct.rb#13
    def inherited(s); end

    # source://packwerk-extensions//lib/packwerk/privacy/package.rb#45
    sig { params(package: ::Packwerk::Package).returns(::String) }
    def public_path_for(package); end

    # source://packwerk-extensions//lib/packwerk/privacy/package.rb#37
    sig { params(package: ::Packwerk::Package).returns(T.nilable(::String)) }
    def user_defined_public_path(package); end
  end
end

# source://packwerk-extensions//lib/packwerk/privacy/validator.rb#6
class Packwerk::Privacy::Validator
  include ::Packwerk::Validator

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#13
  sig do
    override
      .params(
        package_set: Packwerk::PackageSet,
        configuration: ::Packwerk::Configuration
      ).returns(::Packwerk::Validator::Result)
  end
  def call(package_set, configuration); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#33
  sig { override.returns(T::Array[::String]) }
  def permitted_keys; end

  private

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#142
  sig { params(constants: T.untyped, config_file_path: ::String).returns(T::Array[::Packwerk::Validator::Result]) }
  def assert_constants_can_be_loaded(constants, config_file_path); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#95
  sig { params(config_file_path: ::String, setting: T.untyped).returns(::Packwerk::Validator::Result) }
  def check_enforce_privacy_setting(config_file_path, setting); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#125
  sig do
    params(
      location: ::String,
      constant_package: ::Packwerk::Package,
      name: T.untyped
    ).returns(::Packwerk::Validator::Result)
  end
  def check_for_publicized_constant(location, constant_package, name); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#110
  sig do
    params(
      configuration: ::Packwerk::Configuration,
      package_set: Packwerk::PackageSet,
      name: T.untyped,
      location: T.untyped,
      config_file_path: T.untyped
    ).returns(::Packwerk::Validator::Result)
  end
  def check_private_constant_location(configuration, package_set, name, location, config_file_path); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#81
  sig { params(config_file_path: ::String, setting: T.untyped).returns(::Packwerk::Validator::Result) }
  def check_public_path(config_file_path, setting); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#159
  sig { params(name: T.untyped, config_file_path: T.untyped).returns(::Packwerk::Validator::Result) }
  def private_constant_unresolvable(name, config_file_path); end

  # source://packwerk-extensions//lib/packwerk/privacy/validator.rb#40
  sig do
    params(
      package_set: Packwerk::PackageSet,
      configuration: ::Packwerk::Configuration
    ).returns(T::Array[::Packwerk::Validator::Result])
  end
  def verify_private_constants_setting(package_set, configuration); end
end

# source://packwerk-extensions//lib/packwerk/privacy/validator.rb#10
Packwerk::Privacy::Validator::Result = Packwerk::Validator::Result

# source://packwerk-extensions//lib/packwerk/visibility/package.rb#5
module Packwerk::Visibility; end

# Checks whether a given reference references a constant from a package that does not permit visibility
#
# source://packwerk-extensions//lib/packwerk/visibility/checker.rb#10
class Packwerk::Visibility::Checker
  include ::Packwerk::Checker

  # source://packwerk-extensions//lib/packwerk/visibility/checker.rb#26
  sig { override.params(reference: ::Packwerk::Reference).returns(T::Boolean) }
  def invalid_reference?(reference); end

  # source://packwerk-extensions//lib/packwerk/visibility/checker.rb#50
  sig { override.params(reference: ::Packwerk::Reference).returns(::String) }
  def message(reference); end

  # source://packwerk-extensions//lib/packwerk/visibility/checker.rb#40
  sig { override.params(listed_offense: ::Packwerk::ReferenceOffense).returns(T::Boolean) }
  def strict_mode_violation?(listed_offense); end

  # source://packwerk-extensions//lib/packwerk/visibility/checker.rb#17
  sig { override.returns(::String) }
  def violation_type; end

  private

  # source://packwerk-extensions//lib/packwerk/visibility/checker.rb#69
  sig { params(visibility_option: T.nilable(T.any(::String, T::Boolean))).returns(T::Boolean) }
  def enforcement_disabled?(visibility_option); end

  # source://packwerk-extensions//lib/packwerk/visibility/checker.rb#74
  sig { params(reference: ::Packwerk::Reference).returns(::String) }
  def standard_help_message(reference); end
end

# source://packwerk-extensions//lib/packwerk/visibility/checker.rb#14
Packwerk::Visibility::Checker::VIOLATION_TYPE = T.let(T.unsafe(nil), String)

# source://packwerk-extensions//lib/packwerk/visibility/package.rb#6
class Packwerk::Visibility::Package < ::T::Struct
  const :visible_to, T::Array[::String]
  const :enforce_visibility, T.nilable(T.any(::String, T::Boolean))

  class << self
    # source://packwerk-extensions//lib/packwerk/visibility/package.rb#16
    sig { params(package: ::Packwerk::Package).returns(::Packwerk::Visibility::Package) }
    def from(package); end

    # source://sorbet-runtime/0.5.11835/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://packwerk-extensions//lib/packwerk/visibility/validator.rb#6
class Packwerk::Visibility::Validator
  include ::Packwerk::Validator

  # source://packwerk-extensions//lib/packwerk/visibility/validator.rb#13
  sig do
    override
      .params(
        package_set: Packwerk::PackageSet,
        configuration: ::Packwerk::Configuration
      ).returns(::Packwerk::Validator::Result)
  end
  def call(package_set, configuration); end

  # source://packwerk-extensions//lib/packwerk/visibility/validator.rb#54
  sig { override.returns(T::Array[::String]) }
  def permitted_keys; end
end

# source://packwerk-extensions//lib/packwerk/visibility/validator.rb#10
Packwerk::Visibility::Validator::Result = Packwerk::Validator::Result
